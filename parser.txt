OCTET 任意字符
SP 空格
HT Tab键
CTL 控制字符，包括ASCII码：0-31 127
separators     = (  )  < > @ , ; : \ " / [] ? = {} SP HT



token          = 1*<any CHAR except CTLs or separators>，表示重复至少一次<>里面的内容






Request       = Request-Line             
                *(request-header CRLF) 
                CRLF
                [ message-body ]
                      
Request-Line   = Method SP Request-URI SP HTTP-Version CRLF
Method = tocken
Request-URI    = URL允许的字符
HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT

request-header = token ":" token

message-body = entity-body = *OCTET


       message-header = field-name ":" [ field-value ]
       field-name     = token
       field-value    = *( field-content | LWS )
       field-content  = <the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                        of token, separators, and quoted-string>

LWS            = [CRLF] 1*( SP | HT )

TEXT           = <any OCTET except CTLs,
                        but including LWS>

先实现单报文的解析，再看长连接的要求，再想长连接的实现方式。

我的message header的实现：
    message-header = tocken ":" [ field-value ]               
    field-value    = *( *<any OCTET except CTLs> | LWS )

    tocken ":" *( *<any OCTET except CTLs> | LWS )

    tocken ":" *( TEXT_CHAR | LWS )
    TEXT_CHAR = tocken | seps



长连接的信息：
rfc2616 8.1.2.1 Negotiation

1. server默认client需要长连接。如果client的request中包含connection close，服务器则关闭连接。
2. server若决定在发送完response之后关闭连接，response中应该包含connection close。

4. 任意一方发送了close，那么request会是最后一个request。
5. 为了支持长连接，所有的消息必须包含message length。或者是由连接的结束表示message结束


message length的确定的优先级：
1. 1xx，204,304的response，HEAD request，没有message body
2. 有Transfer-Encoding header，且其值不是identity的话，由"chunked" transfer-coding决定（除非连接中断）。
3. 由Content-Length header确定，前提是entity-length和transfer-length一致。（若Transfer-Encoding header也收到了，就忽略Content-Length）。
4. 如果报文有media type "multipart/byteranges"，则由其确定。
5. 由连接的关闭决定。但是这只能确定response的结尾，不能确定request的结尾，因为连接结束后不能回发response了。


Chunked-Body   = *chunk
                        last-chunk
                        trailer
                        CRLF


chunk           =   chunk-size [ chunk-extension ] CRLF
                    chunk-data CRLF
chunk-extension = *(";" *<tocken char, = >)
chunk-size      = 1*HEX
last-chunk      = 1*("0") [ chunk-extension ] CRLF
trailer         = *(entity-header CRLF)


HEX            = "A" | "B" | "C" | "D" | "E" | "F"
                      | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT

4.1 Message Types
In the interest of robustness, servers SHOULD ignore any empty
   line(s) received where a Request-Line is expected. In other words, if
   the server is reading the protocol stream at the beginning of a
   message and receives a CRLF first, it should ignore the CRLF.
4.3 Message Body
The presence of a message-body in a request is signaled by the
   inclusion of a Content-Length or Transfer-Encoding header field in
   the request's message-headers. A message-body MUST NOT be included in
   a request if the specification of the request method (section 5.1.1)
   does not allow sending an entity-body in requests. A server SHOULD
   read and forward a message-body on any request; if the request method
   does not include defined semantics for an entity-body, then the
   message-body SHOULD be ignored when handling the request.